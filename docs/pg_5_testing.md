\page pg_testing Testing

Various testing procedures were created to supplement the explanations and proofs of the previous chapters.

# Automated Testing for Level 2, 4

## generator.py
A Python script was created to test execution and synchronization correctness. The entire program can be found in `generator.py` (see Appendix).

It takes in three arguments:
1. `N_CMDS`: number of commands issued per file
2. `N_FILES`: number of files to issue commands to
3. `RESTRICT`: `y` or `n`; restrict write inputs to alphanumeric chars?

Program usage involves four (4) steps
 -# Run `python3 generator.py <N_CMDS> <N_FILES> <RESTRICT>`
 -# Automatic cleanup of logging constructs
 -# Test input generation
    - Writes to `test.in`
 -# File server execution
    - User must run `./file_server` on a different terminal
    - Copy paste contents of `test.in` into `./file_server`
 -# Once `./file_server` finishes, respond to `generator.py` prompt
   - This generates the expected outputs `./outputs/gen_read.txt`, `./outputs/gen_empty.txt`
   - `commands.txt` is parsed and analyzed by the program

The inputs and paths of the generated commands consist of a variable number of characters - including non-alphanumeric chars. They can have lengths of 1 to at most 50 characters.

Synchronization is tested by keeping track of the expected file contents
over the course of program execution. Every time a `read` or `empty` command is generated, we track the expected output. *This maintains that commands to the same file path must be ordered.*

Each entry of `read.txt` and `empty.txt` is parsed and grouped
by their file path. They are then checked against the expected output.

The total number of threads generated by `./file_server` will be `2 + N_CMDS + N_FILES`. Be careful to not exceed the number of threads allowed by the OS.


## Automated Testing
Bash script `autotest.sh` was used to run the test and output generator `generator.py`. Make sure to give `autotest.sh` execute permission with `chmod +x autotest.sh`.


Outputs of `generator.py` are compared to `read.txt` and `empty.txt`.

```
read_test=$(diff <(sort -t" " -s -k2,2 read.txt) <(sort -t" " -s -k2,2 outputs/gen_read.txt))

if [ -z "$read_test" ];
then
    echo "[PASS] read.txt"
else
    echo "[FAIL] read.txt"
fi

empty_test=$(diff <(sort -t" " -s -k2,2 empty.txt) <(sort -t" " -s -k2,2 outputs/gen_empty.txt))

if [ -z "$empty_test" ];
then
    echo "[PASS] empty.txt"
else
    echo "[FAIL] empty.txt"
fi
```

The `sort ...` commands sort the logging constructs and generated outputs by filename while retaining their order. The `-s` flag indicated stable sort. The `-k2,2` flag indicates that we sort only the second column. The `-t" "` flag assigns whitespace as the column delimiter.

The bash scripts then gets the `diff` of the logging constructs and the generated outputs. The `diff` output should be empty.

This shows us that `./file_server` can
1. Execute commands correctly (Level 2)
2. Execute commands to a specific file synchronously (Level 4)

Note that `generator.py` already analyzes `commands.txt`.

## Test sample
`autotest.sh` uses the following `generator.py` call

```
python3 generator.py 5 20 n
```

Attached is a [sample generated `test.in`](@ref sampletestin) accessing 5 files with 20 commands each. We copy paste this into the terminal after running `./file_server`.

Refer to the Appendix the following outputs
   - [read.txt](@ref sampleread)
   - [empty.txt](@ref sampleempty)
   - [commands.txt](@ref samplecommands)
   - [outputs/gen_read.txt](@ref genread)
   - [outputs/gen_empty.txt](@ref genempty)

# Integrity Test for Level 2, 4

Below is a short integrity test created for testing execution and synchronization correctness (see `integrity.test`). We copy paste this into the terminal after running `./file_server`.

```
write a.txt the
read a.txt
write b.txt the
read b.txt
write a.txt quick
read a.txt
write a.txt brown
write b.txt quick
read a.txt
write a.txt fox
empty a.txt
write a.txt lazy
read b.txt
write a.txt dog
write b.txt brown
read b.txt
write b.txt fox
read a.txt
empty b.txt
write b.txt lazy
write b.txt dog
read b.txt
empty a.txt
empty b.txt
```

This is simply a shuffled version of the input below

```
write a.txt the
read a.txt
write a.txt quick
read a.txt
write a.txt brown
read a.txt
write a.txt fox
empty a.txt
write a.txt lazy
write a.txt dog
read a.txt
write b.txt the
read b.txt
write b.txt quick
read b.txt
write b.txt brown
read b.txt
write b.txt fox
empty b.txt
write b.txt lazy
write b.txt dog
read b.txt
empty a.txt
empty b.txt
```

We sort the read.txt and empty.txt outputs using the following command.

```
sort -t" " -s -k2,2 <read or empty>.txt
```

This allows us to standardize their sequence.

The `sort ...` command sorts the logging constructs by filename while retaining their order. The `-s` flag indicated stable sort. The `-k2,2` flag indicates that we sort only the second column. The `-t" "` flag assigns whitespace as the column delimiter.

## read.txt Expected Output
read.txt should have the standardized output below

```
read a.txt: the
read a.txt: thequick
read a.txt: thequickbrown
read a.txt: lazydog
read b.txt: the
read b.txt: thequick
read b.txt: thequickbrown
read b.txt: lazydog
```

## empty.txt Expected Output
empty.txt should have the standardized output below

```
empty a.txt: thequickbrownfox
empty a.txt: lazydog
empty b.txt: thequickbrownfox
empty b.txt: lazydog
```

## Sample Run

@image latex integritytest.png


# Testing Level 3
Refer to the \ref level3_proof "Concurrency Proof" found in \ref pg_concurrency "Concurrency".
