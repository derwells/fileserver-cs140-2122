\page pg_testing Testing

Various testing procedures were created to supplement the explanations and proofs of the previous chapters.

# Automated Testing for Level 2, 4

## generator.py
A Python script was created to test execution and synchronization correctness. The entire program can be found in `generator.py` (see Appendix).

It takes in three arguments:
1. `N_CMDS`: number of commands issued per file
2. `N_FILES`: number of files to issue commands to
3. `RESTRICT`: `y` or `n`; restrict write inputs to alphanumeric chars?

Program usage involves four (4) steps
 -# Run `python3 generator.py <N_CMDS> <N_FILES> <RESTRICT>`
 -# Automatic cleanup of logging constructs
 -# Test input generation
    - Writes to `test.in`
 -# File server execution
    - User must run `./file_server` on a different terminal
    - Copy paste contents of `test.in` into `./file_server`
 -# Once `./file_server` finishes, respond to `generator.py` prompt
   - This generates the expected outputs `./outputs/gen_read.txt`, `./outputs/gen_empty.txt`
   - `commands.txt` is parsed and analyzed by the program

The inputs and paths of the generated commands consist of a variable number of characters - including non-alphanumeric chars. They can have lengths of 1 to at most 50 characters.

Synchronization is tested by keeping track of the expected file contents
over the course of program execution. Every time a `read` or `empty` command is generated, we track the expected output. *This maintains that commands to the same file path must be ordered.*

Each entry of `read.txt` and `empty.txt` is parsed and grouped
by their file path. They are then checked against the expected output.

The total number of threads generated by `./file_server` will be `2 + N_CMDS + N_FILES`. Be careful to not exceed the number of threads allowed by the OS.


## autotest.sh
Bash script used to run the test and output generator `generator.py`. Outputs of `generator.py` are compared to `read.txt` and `empty.txt`.

```
read_test=$(diff <(sort -t" " -s -k2,2 read.txt) <(sort -t" " -s -k2,2 outputs/gen_read.txt))

if [ -z "$read_test" ];
then
    echo "[PASS] read.txt"
else
    echo "[FAIL] read.txt"
fi

empty_test=$(diff <(sort -t" " -s -k2,2 empty.txt) <(sort -t" " -s -k2,2 outputs/gen_empty.txt))

if [ -z "$empty_test" ];
then
    echo "[PASS] empty.txt"
else
    echo "[FAIL] empty.txt"
fi
```

The `sort ...` inputs sort the logging constructs and generated outputs by filename while retaining their order. The `-s` flag indicated stable sort. The `-k2,2` flag indicates that we sort only the second column. The `-t" "` flag assigns whitespace as the column delimiter.

The bash scripts then gets the `diff` of the logging constructs and the generated outputs. The `diff` output should be empty.

This shows us that `./file_server` can
1. Execute commands correctly (Level 2)
2. Execute commands to a specific file synchronously (Level 4)

Note that `generator.py` already analyzes `commands.txt`.

## Test sample
`autotest.sh` uses the following `generator.py` call

```
python3 generator.py 5 20 n
```

Attached is a [sample generated `test.in`](@ref sampletestin) accessing 5 files with 20 commands each. We copy paste this into the terminal after running `./file_server`.

Refer to the Appendix the following outputs
   - [`read.txt`](@ref sampleread)
   - [`empty.txt`](@ref sampleempty)
   - [`commands.txt`](@ref samplecommands)
   - [`outputs/gen_read.txt`](@ref genread)
   - [`outputs/gen_empty.txt`](@ref genempty)

# Integrity Test for Level 2, 4

Below is a short integrity test created for testing execution 
and synchronization correctness. We copy paste this into the terminal after running `./file_server`.

```
empty a.txt
write a.txt 1 2
write a.txt 3 4
read a.txt
write a.txt 5 6
write b.txt 1 2
write b.txt 3 4
empty a.txt
read a.txt
read a.txt
write a.txt 7 8
read b.txt
read a.txt
empty a.txt
write b.txt 5 6
empty b.txt
read b.txt
write a.txt 9 10
write a.txt 11 12
read b.txt
write b.txt 7 8
read b.txt
empty b.txt
read c.txt
write c.txt 5 6
empty c.txt
read c.txt
write a.txt 13 14
read a.txt
write b.txt 11 12
write c.txt 1 2
write c.txt 3 4
read c.txt
write c.txt 7 8
read c.txt
write b.txt 13 14
read b.txt
empty a.txt
write b.txt 9 10
write c.txt 9 10
empty b.txt
empty c.txt
write c.txt 11 12
write c.txt 13 14
read c.txt
empty c.txt
write d.txt 9 10
read d.txt
empty d.txt
```

The same ordering is followed by the sample `command.txt` output below

```
[Thu Dec 30 18:12:57 2021] empty a.txt
[Thu Dec 30 18:12:57 2021] write a.txt 1 2
[Thu Dec 30 18:12:57 2021] write a.txt 3 4
[Thu Dec 30 18:12:57 2021] read a.txt
[Thu Dec 30 18:12:57 2021] write a.txt 5 6
[Thu Dec 30 18:12:57 2021] write b.txt 1 2
[Thu Dec 30 18:12:57 2021] write b.txt 3 4
[Thu Dec 30 18:12:57 2021] empty a.txt
[Thu Dec 30 18:12:57 2021] read a.txt
[Thu Dec 30 18:12:57 2021] read a.txt
[Thu Dec 30 18:12:57 2021] write a.txt 7 8
[Thu Dec 30 18:12:57 2021] read b.txt
[Thu Dec 30 18:12:57 2021] read a.txt
[Thu Dec 30 18:12:57 2021] empty a.txt
[Thu Dec 30 18:12:57 2021] write b.txt 5 6
[Thu Dec 30 18:12:57 2021] empty b.txt
[Thu Dec 30 18:12:57 2021] read b.txt
[Thu Dec 30 18:12:57 2021] write a.txt 9 10
[Thu Dec 30 18:12:57 2021] write a.txt 11 12
[Thu Dec 30 18:12:57 2021] read b.txt
[Thu Dec 30 18:12:57 2021] write b.txt 7 8
[Thu Dec 30 18:12:57 2021] read b.txt
[Thu Dec 30 18:12:57 2021] empty b.txt
[Thu Dec 30 18:12:57 2021] read c.txt
[Thu Dec 30 18:12:57 2021] write c.txt 5 6
[Thu Dec 30 18:12:57 2021] empty c.txt
[Thu Dec 30 18:12:57 2021] read c.txt
[Thu Dec 30 18:12:57 2021] write a.txt 13 14
[Thu Dec 30 18:12:57 2021] read a.txt
[Thu Dec 30 18:12:57 2021] write b.txt 11 12
[Thu Dec 30 18:12:57 2021] write c.txt 1 2
[Thu Dec 30 18:12:57 2021] write c.txt 3 4
[Thu Dec 30 18:12:57 2021] read c.txt
[Thu Dec 30 18:12:57 2021] write c.txt 7 8
[Thu Dec 30 18:12:57 2021] read c.txt
[Thu Dec 30 18:12:57 2021] write b.txt 13 14
[Thu Dec 30 18:12:57 2021] read b.txt
[Thu Dec 30 18:12:57 2021] empty a.txt
[Thu Dec 30 18:12:57 2021] write b.txt 9 10
[Thu Dec 30 18:12:57 2021] write c.txt 9 10
[Thu Dec 30 18:12:57 2021] empty b.txt
[Thu Dec 30 18:12:57 2021] empty c.txt
[Thu Dec 30 18:12:57 2021] write c.txt 11 12
[Thu Dec 30 18:12:57 2021] write c.txt 13 14
[Thu Dec 30 18:12:57 2021] read c.txt
[Thu Dec 30 18:12:57 2021] empty c.txt
[Thu Dec 30 18:12:57 2021] write d.txt 9 10
[Thu Dec 30 18:12:57 2021] read d.txt
[Thu Dec 30 18:12:57 2021] empty d.txt
```

By analyzing the input we can see the expected `read.txt` and `empty.txt` output of each file
 
`read.txt`
 - `a.txt`: 1 23 4, empty read, empty read, 7 8, 9 1011 1213 14
 - `b.txt`: 12 34, empty read, empty read, 7 8, 11 1213 14
 - `c.txt`: FILE DNE, empty read, 1 23 4, 1 23 47 8, 9 1011 1213 14
 - `d.txt`: 9 10

Inspecting the sample `read.txt` output below, we see that these orderings are reflected

```
read c.txt: FILE DNE
read d.txt: 9 10
read b.txt: 1 23 4
read a.txt: 1 23 4
read c.txt: 
read b.txt: 
read b.txt: 
read c.txt: 1 23 4
read b.txt: 7 8
read c.txt: 1 23 47 8
read a.txt: 
read a.txt: 
read a.txt: 7 8
read b.txt: 11 1213 14
read c.txt: 11 1213 14
read a.txt: 9 1011 1213 14
```

`empty.txt`
 - `a.txt`: FILE ALREADY EMPTY, 1 23 45 6, 7 8, 9 1011 1213 14
 - `b.txt`: 1 23 45 6, 7 8, 11 1213 149 10
 - `c.txt`: 5 6, 1 23 47 89 10, 11 1213 14
 - `d.txt`: 9 10

Inspecting the sample `empty.txt` output below, we see that these orderings are reflected

```
empty a.txt: FILE ALREADY EMPTY
empty c.txt: 5 6
empty d.txt: 9 10
empty b.txt: 1 23 45 6
empty a.txt: 1 23 45 6
empty b.txt: 7 8
empty c.txt: 1 23 47 89 10
empty a.txt: 7 8
empty b.txt: 11 1213 149 10
empty c.txt: 11 1213 14
empty a.txt: 9 1011 1213 14
```

# Testing Level 3
Refer to the \ref level3_proof "Concurrency Proof" found in \ref pg_concurrency "Concurrency".

# Testing Inputs with Newlines
We can test inputs with newlines by issuing the commands

```
read generator.py
read <file that does not exist>
```

Make sure that `read.txt` is cleared beforehand. We can run `diff` to confirm that the only differences are the records on the command issued
!!!
\latexonly
\begin{figure}[H]
   \centering
	\includegraphics[scale=1]{sync_overview.png}
	\caption{`write`, `write` concurrency}
	\label{overview}
\end{figure}
\endlatexonly
